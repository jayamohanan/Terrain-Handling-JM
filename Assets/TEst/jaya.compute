// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
RWStructuredBuffer<float2> points;
RWStructuredBuffer<float3> unitDimensions;//V3(grid.unitWidth, grid.unitLength,grid.unitDepth), v3(grid.rows, grid.columns, grid.stacks) | Length is 2
RWStructuredBuffer<float> maxDst;

float inverseLerp(float value, float min, float max) {
	return saturate((value - min) / (max - min));
}

float Calculate(int2 pixel) {
	float min = 1000.0;
	float2 pixelFloat = float2(pixel.x, pixel.y);
	int xCoord = pixel.x / unitDimensions[0];
	int yCoord = pixel.y / unitDimensions[1];

	for (int i = -1; i < 2; i++)
	{
		for (int j = -1; j < 2; j++)
		{
			int neighbourX = xCoord + i;
			int neighbourY = yCoord + j;
			if (neighbourX >= 0 && neighbourX < unitDimensions[3] && neighbourY >= 0 && neighbourY < unitDimensions[2]) {
				float dst = distance(pixelFloat, points[neighbourX* unitDimensions[2]+ neighbourY]);
				if (dst < min) {
					min = dst;
				}
			}
		}
	}
	return inverseLerp(min, 0.0, maxDst[0]);
}

float Calculate3D(float3 point) {
	float min = 1000.0;
	uint3 gridIndex = floor(point);
	uint3 neighbourGridIndex;

	int stacks = unitDimensions[1].z;
	int rows = unitDimensions[1].x;
	int columns = unitDimensions[1].y;
	for (int i = -1; i < 2; i++)
	{
		for (int j = -1; j < 2; j++)
		{
			for (int k = -1; k < 2; k++)
			{
				neighbourGridIndex = gridIndex + uint3(i, j, k);
				if (min(neighbourGridIndex.x, min(neighbourGridIndex.y, neighbourGridIndex.z)) == -1 || (neighbourGridIndex.x == columns || neighbourGridIndex.y == rows || neighbourGridIndex.z == stacks))
				{
					continue;
				}
				else {
					neighbourPointIndex = neighbourGridIndex.x * columns + neighbourGridIndex.y + neighbourGridIndex.z * columns * rows;
					dst = distance(point, points[neighbourPointIndex]);
					if (dst < min) {
						min = dst;
					}
				}
			}
		}
	}
	return min;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

	float col = Calculate(int2(id.x, id.y));
	float inverseCol = 1 - col;
    //Result[id.xy] = float4(col, col,col, 1);
    Result[id.xy] = float4(inverseCol, inverseCol, inverseCol, 1);
}